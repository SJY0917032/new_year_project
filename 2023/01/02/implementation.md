# 구현

`머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정` 

> 어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수 이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제를 포함하는 개념
생각해낸 문제 풀이 방법을 우리가 원하는 프로그래밍 언어로 정확히 구현해냈을 때 비로소 정답 처리를 받을 수 있다.

`이코테`책에선 `완전탐색`, `시뮬레이션` 유형을 모두 `구현`으로 묶어서 다루고있다. 
> 완전탐색 : 모든 경우의 수를 주저 없이 다 계산하는 방법
> 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행해야 하는 문제.

## [상하좌우](%EC%83%81%ED%95%98%EC%A2%8C%EC%9A%B0.py)

요구사항대로 `구현`한다면 이동횟수가 연산횟수랑 비레한다. 따라서, 이 문제의 시간 복잡도는 매우 넉넉한편이다.
이러한 문제는 일련의 명령에 따라서 개체를 차례대로 이동시킨다는 점에서 `시뮬레이션`유형이며 구현이 중요한 대표적인 문제 유형이다.

## [시각](%EC%8B%9C%EA%B0%81.py)

이 문제는 모든 시각의 경우를 하나씩 모두 세서 풀수있다 (하루는 `00~24`까지 `86,400`가지밖에 존재하지 않기 때문.)
이러한 유형은 `완전탐색` 유형으로 분류된다, 완전탐색 알고리즘은 비효율적인 시간복잡도를 가지고 있으므로 데이터가 큰 경우 정상적으로 동작하지 않을 수 있다.
그래서 일반적으로 데이터가 100만개 이하인 경우에 완전탐색을하면 적절하다.

## [왕실의 나이트](%EC%99%95%EC%8B%A4%EC%9D%98%20%EB%82%98%EC%9D%B4%ED%8A%B8.py)

위의 상하좌우 문제와 유사하다 다만, 8 X 8 평면을 벗어나지 않도록 꼼꼼하게 체크하는것이 중요하다.
조금 더 까다롭게 문제를 출제한다면 입력문자가 열과 행이 아닌 1a와 같은 행과 열로 들어왔을때의 예외처리를 요구할 수도있다.

상하좌우 문제에서는 `dx,dy`리스트를 선언하여 이동할 방향을 기록했다면, 이 문제에선 `move`로 이동할 방향을 기록했다 (2가지 형태 모두 자주 사용되므로 기억하는것이 좋음.)

## [게임 개발](%EA%B2%8C%EC%9E%84%20%EA%B0%9C%EB%B0%9C.py)

`시뮬레이션 문제` 별도의 알고리즘이 필요하기보다는 문제에서 요구하는 내용을 오류없이 성실하게 구현만 한다면 풀 수 있다.

> 문제 풀이에 필요한 테크닉을 설명하자면, 일반적으로 방향을 설정하여 이동하는 문제는 dx,dy라는 리스트를 만들거나 move[(), ()]와 같이 방향을 정하는것이 효과적이다.

예를들어 북쪽으로 이동하기위해 x,y를 이동한다면 move[북쪽][0], move[북쪽][1]만큼 더하면 된다 이처럼 코드를 작성하면 반복문으로 모든 방향을 확인할수있다.
그리고 리스트 컴프리헨션 문법을 사용해 2차원 리스트를 초기화하면 효율적이다.
