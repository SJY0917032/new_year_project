# 그리디

현재상황에서 지금 당장 좋은것을 고르는 방법
> 예를들어 여러 개의 데이터를 빠르게 정렬해야한다?
  다익스트라 알고리즘이나 플로이드워셜과 같은 특정알고리즘으로 풀어야한다.

하지만 그리디 문제자체가 폭이 너무 넓기때문에 단순 암기를 통해 모든 문제를 대처하기 어렵다.

그리디알고리즘은 기준에 따라 좋은것을 선택하는 알고리즘이므로 문제에서 `가장 큰 순서대로`, `가장 자근 순서대로`와 같은 기준으로 알게 모르게 제시해준다.

대체로 그리디는 `정렬`과 짝을 이뤄 출제된다.


## [큰 수의 법칙](%ED%81%B0%20%EC%88%98%EC%9D%98%20%EB%B2%95%EC%B9%99.py)

이 문제를 풀려면 반복되는 수열에 대해서 파악해야한다.

가장 큰 수와 두번재로 큰 수가 더해질때는 특정한 수열로 일정하게 반복해서 더해지는 특징이 있다.

그렇다면 반복되는 수열의 길이는 어떻게 될까? (K번 반복하고 두번째를 한번하면 다시 첫번째로 돌아가는게 가능하기때문에 `K + 1`이 된다)
따라서 `M`을 (`K+1`)로 나눈 몫이 수열이 반복되는 횟수가 된다 다시, 여기에 K를 곱해준다면 `가장 큰 수`가 등장하는 횟수가 된다.


## [숫자 카드 게임](%EC%88%AB%EC%9E%90%20%EC%B9%B4%EB%93%9C%20%EA%B2%8C%EC%9E%84.py)

이 문제를 푸는 아이디어는 `각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수`를 찾는 것이다.
입력 조건에서 입력으로 들어오는 수는 모두 `10,000` 이하이므로 단순히 배열에서 가장 작은 수를 찾는 기본 문법을 이용하여
가장 작은 수를 찾은 다음, 그 수에서 가장 큰수를 찾는 방법으로 문제를 해결할 수 있다.

## [1이 될 때까지](1%EC%9D%B4%20%EB%90%A0%20%EB%95%8C%EA%B9%8C%EC%A7%80.py)

이 문제는 `최대한 많이 나누기`를 수행하면 더 최적의 해를 구할수 있다.
왜냐하면 `2 이상의 수로 나누는 것`이 `1을 빼는것`보다 숫자를 훨씬 많이 줄일 수 있기 때문이다.
문제에서는 `K`가 `2 이상의 자연수`이므로 가능하면 나누는 것이 항상 더 숫자를 빠르게 줄이는 방법이 된다.

문제에서는 `N`의 범위가 10만 이하이므로 이처럼 일일이 1씩 빼도 문제를 해결할 수 있다. 하지만 `N`이 100억 이상의 큰 수가 되는경우를 가정한다면?
`N`이 `K`의 배수가 되도록 효율적으로 한 번에 빼는것이 좋다.
